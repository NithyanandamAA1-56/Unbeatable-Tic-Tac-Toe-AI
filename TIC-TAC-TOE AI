import math

# --- 1. Game Board Setup and State Functions ---

def print_board(board):
    """Prints the Tic-Tac-Toe board."""
    print(f"\n {board[0]} | {board[1]} | {board[2]} ")
    print("---|---|---")
    print(f" {board[3]} | {board[4]} | {board[5]} ")
    print("---|---|---")
    print(f" {board[6]} | {board[7]} | {board[8]} \n")

def check_winner(board, player):
    """Checks if the given player has won."""
    # Define all winning combinations (rows, columns, diagonals)
    winning_combinations = [
        (0, 1, 2), (3, 4, 5), (6, 7, 8),  # Rows
        (0, 3, 6), (1, 4, 7), (2, 5, 8),  # Columns
        (0, 4, 8), (2, 4, 6)             # Diagonals
    ]
    
    # Check if the player occupies all positions in any winning combination
    for combo in winning_combinations:
        if all(board[i] == player for i in combo):
            return True
    return False

def is_board_full(board):
    """Checks if the board is completely filled (a draw)."""
    return " " not in board

def get_available_moves(board):
    """Returns a list of indices for empty spots."""
    return [i for i, spot in enumerate(board) if spot == " "]

# --- 2. Minimax Algorithm Implementation ---

def minimax(board, depth, is_maximizing):
    """
    The core recursive function for the Minimax algorithm.
    :param board: The current state of the board.
    :param depth: How many moves deep the algorithm is searching (used to prefer faster wins/losses).
    :param is_maximizing: True if it's the AI's turn (Maximizer), False if it's the Human's turn (Minimizer).
    :return: The score of the current board state.
    """
    ai_player = 'O'
    human_player = 'X'

    # Check for terminal states (Win, Loss, or Draw)
    if check_winner(board, ai_player):
        # AI wins: return a high positive score, adjusted by depth
        # Less depth means a faster win, which is better
        return 10 - depth 
    
    if check_winner(board, human_player):
        # Human wins: return a high negative score, adjusted by depth
        # Less depth means a faster loss, which is worse
        return depth - 10
    
    if is_board_full(board):
        # Draw
        return 0

    # Minimax logic
    if is_maximizing:
        # AI's turn: Maximizer wants the highest possible score
        best_score = -math.inf
        for move in get_available_moves(board):
            board[move] = ai_player  # Make the move
            score = minimax(board, depth + 1, False) # Recurse for the human's turn
            board[move] = " "        # Undo the move (backtrack)
            best_score = max(best_score, score)
        return best_score
    else:
        # Human's turn: Minimizer wants the lowest possible score
        best_score = math.inf
        for move in get_available_moves(board):
            board[move] = human_player # Make the move
            score = minimax(board, depth + 1, True) # Recurse for the AI's turn
            board[move] = " "          # Undo the move (backtrack)
            best_score = min(best_score, score)
        return best_score

def find_best_move(board):
    """Finds the optimal move for the AI using Minimax."""
    best_score = -math.inf
    best_move = -1
    ai_player = 'O'

    # Iterate through all available moves and find the one that yields the highest minimax score
    for move in get_available_moves(board):
        board[move] = ai_player      # Make the temporary move
        score = minimax(board, 0, False) # Evaluate the resulting board state (depth 0, next turn is Minimizing)
        board[move] = " "            # Undo the move
        
        if score > best_score:
            best_score = score
            best_move = move
            
    return best_move

# --- 3. Main Game Loop ---

def play_game():
    """Manages the overall game flow."""
    # Initialize the board with indices for player reference (1-9)
    # The actual game board uses ' ' for empty spots and 0-8 indices internally
    current_board = ["1", "2", "3", "4", "5", "6", "7", "8", "9"]
    print("\n--- Tic-Tac-Toe ---")
    print("The board positions correspond to the numbers shown below:")
    print_board(current_board)
    
    # Initialize the actual empty board
    board = [" "] * 9
    
    human_player = 'X'
    ai_player = 'O'
    current_turn = human_player

    print("You are 'X'. I am 'O'. You go first.")
    
    # Main game loop
    while not check_winner(board, human_player) and not check_winner(board, ai_player) and not is_board_full(board):
        
        print(f"\nIt is {current_turn}'s turn.")
        print_board(board)
        
        if current_turn == human_player:
            # Human Player's Turn
            try:
                # Get input (1-9), convert to 0-8 index
                move = int(input(f"Enter your move (1-9): ")) - 1
                
                if move in range(9) and board[move] == " ":
                    board[move] = human_player
                    current_turn = ai_player
                else:
                    print("Invalid move. Please choose an empty spot (1-9).")
            except ValueError:
                print("Invalid input. Please enter a number.")
        
        else:
            # AI Player's Turn
            print("AI is calculating its move...")
            move = find_best_move(board)
            board[move] = ai_player
            current_turn = human_player
            print(f"AI plays position {move + 1}.")

    # --- Game End Condition ---
    
    print_board(board)
    
    if check_winner(board, human_player):
        print("üéâ Congratulations! You win! (That shouldn't happen if the AI is perfect!)")
    elif check_winner(board, ai_player):
        print("ü§ñ AI wins! Better luck next time!")
    else:
        print("ü§ù It's a draw!")

# Uncomment the line below to run the game
# play_game()
